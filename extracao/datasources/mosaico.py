# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/01d_mosaico.ipynb.

# %% auto 0
__all__ = ['MONGO_URI', 'Mosaico']

# %% ../../nbs/01d_mosaico.ipynb 3
import os

import pandas as pd
from dotenv import find_dotenv, load_dotenv
from fastcore.foundation import GetAttr

from .connectors import MongoDB
from .base import Base

# %% ../../nbs/01d_mosaico.ipynb 4
load_dotenv(find_dotenv(), override=True)

# %% ../../nbs/01d_mosaico.ipynb 6
MONGO_URI = os.environ.get('MONGO_URI', '')
pd.options.mode.copy_on_write = True


# %% ../../nbs/01d_mosaico.ipynb 7
class Mosaico(Base, GetAttr):
	"""Base Class with the common API from the MOSAICO MongoDB Source"""

	def __init__(self, mongo_uri: str = MONGO_URI, read_cache: bool = False):
		self.read_cache = read_cache
		self.database = 'sms'
		self.default = MongoDB(mongo_uri)

	@property
	def collection(self):
		raise NotImplementedError("Subclasses should implement the property 'collection'")

	@property
	def query(self):
		raise NotImplementedError("Subclasses should implement the property 'query'")

	@property
	def projection(self):
		raise NotImplementedError("Subclasses should implement the property 'projection'")

	def _extract(self, collection: str, pipeline: list):
		if self.read_cache:
			return self._read(f'{self.stem}_raw')
		client = self.connect()
		database = client[self.database]
		db_collection = database[collection]
		df = pd.DataFrame(list(db_collection.aggregate(pipeline)), copy=False, dtype='string')
		# Substitui strings vazias, espaços e listas vazias por nulo
		df = df.replace(r'^\s*$|^\[\]$', pd.NA, regex=True)
		# Create the Log Column
		df['Log'] = '[]'
		return df

	@staticmethod
	def split_designacao(
		df: pd.DataFrame,  # DataFrame com coluna original DesignacaoEmissao
	) -> pd.DataFrame:  # DataFrame com novas colunas Largura_Emissão(kHz) e Classe_Emissão
		"""Parse a bandwidth string
		It returns the numerical component and a character class
		"""

		# split then explode
		df['Temp'] = (
			df['Designação_Emissão'].str.replace(',', ' ').str.strip().str.upper().str.split(' ')
		)
		exploded_rows = df['Temp'].apply(lambda x: isinstance(x, list))
		# Log
		column = 'Designação_Emissão'
		processing = 'Registro expandido em Largura_Emissão(kHz) e Classe_Emissão'
		log_tuple = (column, processing, column)
		Base.register_log(df, log_tuple, exploded_rows)

		df = df.explode('Temp').reset_index(drop=True)
		df = df[df['Temp'] != '/']  # Removes empty rows
		df['Temp'] = df['Temp'].astype('string', copy=False).fillna('')

		# Apply the parse_bw function
		parsed_data = zip(*df['Temp'].apply(Base.parse_bw))

		df['Largura_Emissão(kHz)'], df['Classe_Emissão'] = parsed_data
		df['Largura_Emissão(kHz)'] = df['Largura_Emissão(kHz)'].astype('string', copy=False)
		df['Classe_Emissão'] = df['Classe_Emissão'].astype('string', copy=False)
		return df.drop(['Designação_Emissão', 'Temp'], axis=1)
