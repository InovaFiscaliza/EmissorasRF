# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/01d_mosaico.ipynb.

# %% auto 0
__all__ = ['MONGO_URI', 'Mosaico']

# %% ../../nbs/01d_mosaico.ipynb 3
import os

import pandas as pd
from dotenv import find_dotenv, load_dotenv
from fastcore.foundation import GetAttr

from .connectors import MongoDB
from .base import Base

# %% ../../nbs/01d_mosaico.ipynb 4
load_dotenv(find_dotenv(), override=True)

# %% ../../nbs/01d_mosaico.ipynb 6
MONGO_URI = os.environ.get('MONGO_URI')


# %% ../../nbs/01d_mosaico.ipynb 7
class Mosaico(Base, GetAttr):
	"""Base Class with the common API from the MOSAICO MongoDB Source"""

	def __init__(self, mongo_uri: str = MONGO_URI):
		self.database = 'sms'
		self.default = MongoDB(mongo_uri)

	@property
	def collection(self):
		raise NotImplementedError("Subclasses should implement the property 'collection'")

	@property
	def query(self):
		raise NotImplementedError("Subclasses should implement the property 'query'")

	@property
	def projection(self):
		raise NotImplementedError("Subclasses should implement the property 'projection'")

	def _extract(self, collection: str, pipeline: list):
		client = self.connect()
		database = client[self.database]
		db_collection = database[collection]
		df = pd.DataFrame(list(db_collection.aggregate(pipeline)), copy=False, dtype='string')
		# Substitui strings vazias e somente com espaços por nulo
		return df.replace(r'^\s*|\[\]', pd.NA, regex=True)

	def split_designacao(
		self,
		df: pd.DataFrame,  # DataFrame com coluna original DesignacaoEmissao
	) -> pd.DataFrame:  # DataFrame com novas colunas Largura_Emissão(kHz) e Classe_Emissão
		"""Parse a bandwidth string
		It returns the numerical component and a character class
		"""
		df['Designação_Emissão'] = df['Designação_Emissão'].astype('string', copy=False)
		df['Designação_Emissão'] = (
			df['Designação_Emissão'].str.replace(',', ' ').str.strip().str.upper().str.split(' ')
		)
		exploded_rows = df['Designação_Emissão'].apply(lambda x: isinstance(x, list))
		log = """[("Colunas", "Designação_Emissão"]),
		          ("Processamento", "Registro expandido nos componentes individuais e extraídas Largura e Classe")]"""
		df = self.register_log(df, log, exploded_rows)
		df = df.explode('Designação_Emissão').reset_index(drop=True)

		df = df[df['Designação_Emissão'] != '/']  # Removes empty rows
		df['Designação_Emissão'] = df['Designação_Emissão'].astype('string', copy=False)
		# Apply the parse_bw function
		parsed_data = zip(*df['Designação_Emissão'].apply(Base.parse_bw))
		df['Largura_Emissão(kHz)'], df['Classe_Emissão'] = parsed_data
		return df.drop('Designação_Emissão', axis=1)
