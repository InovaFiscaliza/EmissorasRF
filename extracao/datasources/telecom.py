# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/01f_telecom.ipynb.

# %% auto 0
__all__ = ['MONGO_URI', 'Telecom']

# %% ../../nbs/01f_telecom.ipynb 3
import os
import gc


import pandas as pd

from dotenv import find_dotenv, load_dotenv

from extracao.constants import (
	AGG_LICENCIAMENTO,
	COLUNAS,
	DICT_LICENCIAMENTO,
	MONGO_TELECOM,
	PROJECTION_LICENCIAMENTO,
)

from .mosaico import Mosaico

# %% ../../nbs/01f_telecom.ipynb 4
load_dotenv(find_dotenv())

# %% ../../nbs/01f_telecom.ipynb 6
MONGO_URI = os.environ.get('MONGO_URI', '')
pd.options.mode.copy_on_write = True


# %% ../../nbs/01f_telecom.ipynb 7
class Telecom(Mosaico):
	"""This class encapsulates the extraction and processing of Telecommunications Services from the MOSAICO MongoDB"""

	def __init__(
		self, mongo_uri: str = MONGO_URI, limit: int = 0, read_cache: bool = False
	) -> None:
		super().__init__(mongo_uri, read_cache)
		self.limit = limit

	@property
	def stem(self):
		return 'telecom'

	@property
	def collection(self):
		return 'licenciamento'

	@property
	def query(self):
		return MONGO_TELECOM

	@property
	def projection(self):
		return PROJECTION_LICENCIAMENTO

	@property
	def columns(self):
		return COLUNAS

	@property
	def cols_mapping(self):
		return DICT_LICENCIAMENTO

	def extraction(self) -> pd.DataFrame:
		"""Extract the data from the MOSAICO MongoDB collection"""
		pipeline = [{'$match': self.query}, {'$project': self.projection}]
		if self.limit > 0:
			pipeline.append({'$limit': self.limit})
		df = self._extract(self.collection, pipeline)
		return df

	def _format(
		self,
		df: pd.DataFrame,  # Source dataframe
	) -> pd.DataFrame:  # Final processed dataframe
		"""Formats, cleans, groups and standardizes the queried data from the database"""
		df = df.rename(columns=self.cols_mapping)
		df = Mosaico.split_designacao(df)
		duplicated = df.duplicated(subset=AGG_LICENCIAMENTO, keep='first')

		# Discard and Log
		df_temp = df[duplicated]
		processing = (
			f'Registro agregado no arquivo final. Colunas Consideradas: {AGG_LICENCIAMENTO}'
		)
		Mosaico.register_log(df_temp, processing)
		self.append2discarded(df_temp)

		# I didn't find a better way to do this, the LLMs suggested were wrong!
		df_temp = df[~duplicated]
		df_sub = df_temp.dropna(subset=AGG_LICENCIAMENTO)
		df_temp = df_temp.loc[~df_temp.index.isin(df_sub.index)]

		# Discard and Log dropped rows
		processing = (
			f'Registro removido por conter valores nulos. Colunas Consideradas: {AGG_LICENCIAMENTO}'
		)
		Mosaico.register_log(df_temp, processing)
		self.append2discarded(df_temp)

		df_sub['Multiplicidade'] = (
			df.groupby(AGG_LICENCIAMENTO, dropna=True, sort=False, observed=True).size().values
		)
		del df, df_temp
		gc.collect()

		processing = f'Registro agrupado. Colunas consideradas: {AGG_LICENCIAMENTO}'
		Mosaico.register_log(df_sub[df_sub['Multiplicidade'] > 1], processing)

		df_sub['Status'] = 'L'
		df_sub['Status'] = df_sub['Status'].astype('string', copy=False)
		df_sub['Fonte'] = 'MOSAICO-LIC'
		df_sub['Fonte'] = df_sub['Fonte'].astype('string', copy=False)
		df_sub['Multiplicidade'] = df_sub['Multiplicidade'].astype('string', copy=False)
		return df_sub.loc[:, self.columns]
